"use strict";
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", { value: true });
exports.Actions = void 0;
const resource_1 = require("../../core/resource.js");
const path_1 = require("../../internal/utils/path.js");
class Actions extends resource_1.APIResource {
    /**
     * Add messages to the conversation started by an AI assistant on the call.
     *
     * @example
     * ```ts
     * const response =
     *   await client.calls.actions.addAIAssistantMessages(
     *     'call_control_id',
     *   );
     * ```
     */
    addAIAssistantMessages(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/ai_assistant_add_messages`, {
            body,
            ...options,
        });
    }
    /**
     * Answer an incoming call. You must issue this command before executing subsequent
     * commands on an incoming call.
     *
     * **Expected Webhooks:**
     *
     * - `call.answered`
     * - `streaming.started`, `streaming.stopped` or `streaming.failed` if `stream_url`
     *   was set
     *
     * When the `record` parameter is set to `record-from-answer`, the response will
     * include a `recording_id` field.
     *
     * @example
     * ```ts
     * const response = await client.calls.actions.answer(
     *   'call_control_id',
     * );
     * ```
     */
    answer(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/answer`, { body, ...options });
    }
    /**
     * Bridge two call control calls.
     *
     * **Expected Webhooks:**
     *
     * - `call.bridged` for Leg A
     * - `call.bridged` for Leg B
     *
     * @example
     * ```ts
     * const response = await client.calls.actions.bridge(
     *   'call_control_id',
     *   {
     *     call_control_id_to_bridge_with:
     *       'v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg',
     *   },
     * );
     * ```
     */
    bridge(callControlIDToBridge, params, options) {
        const { call_control_id_to_bridge_with, ...body } = params;
        return this._client.post((0, path_1.path) `/calls/${callControlIDToBridge}/actions/bridge`, {
            body: { call_control_id: call_control_id_to_bridge_with, ...body },
            ...options,
        });
    }
    /**
     * Put the call in a queue.
     *
     * @example
     * ```ts
     * const response = await client.calls.actions.enqueue(
     *   'call_control_id',
     *   { queue_name: 'support' },
     * );
     * ```
     */
    enqueue(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/enqueue`, { body, ...options });
    }
    /**
     * Gather DTMF signals to build interactive menus.
     *
     * You can pass a list of valid digits. The `Answer` command must be issued before
     * the `gather` command.
     *
     * **Expected Webhooks:**
     *
     * - `call.dtmf.received` (you may receive many of these webhooks)
     * - `call.gather.ended`
     *
     * @example
     * ```ts
     * const response = await client.calls.actions.gather(
     *   'call_control_id',
     * );
     * ```
     */
    gather(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/gather`, { body, ...options });
    }
    /**
     * Gather parameters defined in the request payload using a voice assistant.
     *
     * You can pass parameters described as a JSON Schema object and the voice
     * assistant will attempt to gather these informations.
     *
     * **Expected Webhooks:**
     *
     * - `call.ai_gather.ended`
     * - `call.conversation.ended`
     * - `call.ai_gather.partial_results` (if `send_partial_results` is set to `true`)
     * - `call.ai_gather.message_history_updated` (if `send_message_history_updates` is
     *   set to `true`)
     *
     * @example
     * ```ts
     * const response = await client.calls.actions.gatherUsingAI(
     *   'call_control_id',
     *   {
     *     parameters: {
     *       properties: 'bar',
     *       required: 'bar',
     *       type: 'bar',
     *     },
     *   },
     * );
     * ```
     */
    gatherUsingAI(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/gather_using_ai`, { body, ...options });
    }
    /**
     * Play an audio file on the call until the required DTMF signals are gathered to
     * build interactive menus.
     *
     * You can pass a list of valid digits along with an 'invalid_audio_url', which
     * will be played back at the beginning of each prompt. Playback will be
     * interrupted when a DTMF signal is received. The
     * `Answer command must be issued before the `gather_using_audio` command.
     *
     * **Expected Webhooks:**
     *
     * - `call.playback.started`
     * - `call.playback.ended`
     * - `call.dtmf.received` (you may receive many of these webhooks)
     * - `call.gather.ended`
     *
     * @example
     * ```ts
     * const response =
     *   await client.calls.actions.gatherUsingAudio(
     *     'call_control_id',
     *   );
     * ```
     */
    gatherUsingAudio(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/gather_using_audio`, { body, ...options });
    }
    /**
     * Convert text to speech and play it on the call until the required DTMF signals
     * are gathered to build interactive menus.
     *
     * You can pass a list of valid digits along with an 'invalid_payload', which will
     * be played back at the beginning of each prompt. Speech will be interrupted when
     * a DTMF signal is received. The `Answer` command must be issued before the
     * `gather_using_speak` command.
     *
     * **Expected Webhooks:**
     *
     * - `call.dtmf.received` (you may receive many of these webhooks)
     * - `call.gather.ended`
     *
     * @example
     * ```ts
     * const response =
     *   await client.calls.actions.gatherUsingSpeak(
     *     'call_control_id',
     *     { payload: 'say this on call', voice: 'male' },
     *   );
     * ```
     */
    gatherUsingSpeak(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/gather_using_speak`, { body, ...options });
    }
    /**
     * Hang up the call.
     *
     * **Expected Webhooks:**
     *
     * - `call.hangup`
     * - `call.recording.saved`
     *
     * @example
     * ```ts
     * const response = await client.calls.actions.hangup(
     *   'call_control_id',
     * );
     * ```
     */
    hangup(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/hangup`, { body, ...options });
    }
    /**
     * Removes the call from a queue.
     *
     * @example
     * ```ts
     * const response = await client.calls.actions.leaveQueue(
     *   'call_control_id',
     * );
     * ```
     */
    leaveQueue(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/leave_queue`, { body, ...options });
    }
    /**
     * Pause recording the call. Recording can be resumed via Resume recording command.
     *
     * **Expected Webhooks:**
     *
     * There are no webhooks associated with this command.
     *
     * @example
     * ```ts
     * const response = await client.calls.actions.pauseRecording(
     *   'call_control_id',
     * );
     * ```
     */
    pauseRecording(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/record_pause`, { body, ...options });
    }
    /**
     * Initiate a SIP Refer on a Call Control call. You can initiate a SIP Refer at any
     * point in the duration of a call.
     *
     * **Expected Webhooks:**
     *
     * - `call.refer.started`
     * - `call.refer.completed`
     * - `call.refer.failed`
     *
     * @example
     * ```ts
     * const response = await client.calls.actions.refer(
     *   'call_control_id',
     *   {
     *     sip_address: 'sip:username@sip.non-telnyx-address.com',
     *   },
     * );
     * ```
     */
    refer(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/refer`, { body, ...options });
    }
    /**
     * Reject an incoming call.
     *
     * **Expected Webhooks:**
     *
     * - `call.hangup`
     *
     * @example
     * ```ts
     * const response = await client.calls.actions.reject(
     *   'call_control_id',
     *   { cause: 'USER_BUSY' },
     * );
     * ```
     */
    reject(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/reject`, { body, ...options });
    }
    /**
     * Resume recording the call.
     *
     * **Expected Webhooks:**
     *
     * There are no webhooks associated with this command.
     *
     * @example
     * ```ts
     * const response = await client.calls.actions.resumeRecording(
     *   'call_control_id',
     * );
     * ```
     */
    resumeRecording(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/record_resume`, { body, ...options });
    }
    /**
     * Sends DTMF tones from this leg. DTMF tones will be heard by the other end of the
     * call.
     *
     * **Expected Webhooks:**
     *
     * There are no webhooks associated with this command.
     *
     * @example
     * ```ts
     * const response = await client.calls.actions.sendDtmf(
     *   'call_control_id',
     *   { digits: '1www2WABCDw9' },
     * );
     * ```
     */
    sendDtmf(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/send_dtmf`, { body, ...options });
    }
    /**
     * Sends SIP info from this leg.
     *
     * **Expected Webhooks:**
     *
     * - `call.sip_info.received` (to be received on the target call leg)
     *
     * @example
     * ```ts
     * const response = await client.calls.actions.sendSipInfo(
     *   'call_control_id',
     *   {
     *     body: '{"key": "value", "numValue": 100}',
     *     content_type: 'application/json',
     *   },
     * );
     * ```
     */
    sendSipInfo(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/send_sip_info`, { body, ...options });
    }
    /**
     * Convert text to speech and play it back on the call. If multiple speak text
     * commands are issued consecutively, the audio files will be placed in a queue
     * awaiting playback.
     *
     * **Expected Webhooks:**
     *
     * - `call.speak.started`
     * - `call.speak.ended`
     *
     * @example
     * ```ts
     * const response = await client.calls.actions.speak(
     *   'call_control_id',
     *   { payload: 'Say this on the call', voice: 'female' },
     * );
     * ```
     */
    speak(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/speak`, { body, ...options });
    }
    /**
     * Start an AI assistant on the call.
     *
     * **Expected Webhooks:**
     *
     * - `call.conversation.ended`
     * - `call.conversation_insights.generated`
     *
     * @example
     * ```ts
     * const response =
     *   await client.calls.actions.startAIAssistant(
     *     'call_control_id',
     *   );
     * ```
     */
    startAIAssistant(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/ai_assistant_start`, { body, ...options });
    }
    /**
     * Call forking allows you to stream the media from a call to a specific target in
     * realtime. This stream can be used to enable realtime audio analysis to support a
     * variety of use cases, including fraud detection, or the creation of AI-generated
     * audio responses. Requests must specify either the `target` attribute or the `rx`
     * and `tx` attributes.
     *
     * **Expected Webhooks:**
     *
     * - `call.fork.started`
     * - `call.fork.stopped`
     *
     * @example
     * ```ts
     * const response = await client.calls.actions.startForking(
     *   'call_control_id',
     * );
     * ```
     */
    startForking(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/fork_start`, { body, ...options });
    }
    /**
     * Noise Suppression Start (BETA)
     *
     * @example
     * ```ts
     * const response =
     *   await client.calls.actions.startNoiseSuppression(
     *     'call_control_id',
     *   );
     * ```
     */
    startNoiseSuppression(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/suppression_start`, { body, ...options });
    }
    /**
     * Play an audio file on the call. If multiple play audio commands are issued
     * consecutively, the audio files will be placed in a queue awaiting playback.
     *
     * _Notes:_
     *
     * - When `overlay` is enabled, `target_legs` is limited to `self`.
     * - A customer cannot Play Audio with `overlay=true` unless there is a Play Audio
     *   with `overlay=false` actively playing.
     *
     * **Expected Webhooks:**
     *
     * - `call.playback.started`
     * - `call.playback.ended`
     *
     * @example
     * ```ts
     * const response = await client.calls.actions.startPlayback(
     *   'call_control_id',
     * );
     * ```
     */
    startPlayback(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/playback_start`, { body, ...options });
    }
    /**
     * Start recording the call. Recording will stop on call hang-up, or can be
     * initiated via the Stop Recording command.
     *
     * **Expected Webhooks:**
     *
     * - `call.recording.saved`
     * - `call.recording.transcription.saved`
     * - `call.recording.error`
     *
     * @example
     * ```ts
     * const response = await client.calls.actions.startRecording(
     *   'call_control_id',
     *   { channels: 'single', format: 'wav' },
     * );
     * ```
     */
    startRecording(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/record_start`, { body, ...options });
    }
    /**
     * Start siprec session to configured in SIPREC connector SRS.
     *
     * **Expected Webhooks:**
     *
     * - `siprec.started`
     * - `siprec.stopped`
     * - `siprec.failed`
     *
     * @example
     * ```ts
     * const response = await client.calls.actions.startSiprec(
     *   'call_control_id',
     * );
     * ```
     */
    startSiprec(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/siprec_start`, { body, ...options });
    }
    /**
     * Start streaming the media from a call to a specific WebSocket address or
     * Dialogflow connection in near-realtime. Audio will be delivered as
     * base64-encoded RTP payload (raw audio), wrapped in JSON payloads.
     *
     * Please find more details about media streaming messages specification under the
     * [link](https://developers.telnyx.com/docs/voice/programmable-voice/media-streaming).
     *
     * @example
     * ```ts
     * const response = await client.calls.actions.startStreaming(
     *   'call_control_id',
     * );
     * ```
     */
    startStreaming(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/streaming_start`, { body, ...options });
    }
    /**
     * Start real-time transcription. Transcription will stop on call hang-up, or can
     * be initiated via the Transcription stop command.
     *
     * **Expected Webhooks:**
     *
     * - `call.transcription`
     *
     * @example
     * ```ts
     * const response =
     *   await client.calls.actions.startTranscription(
     *     'call_control_id',
     *   );
     * ```
     */
    startTranscription(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/transcription_start`, { body, ...options });
    }
    /**
     * Stop an AI assistant on the call.
     *
     * @example
     * ```ts
     * const response = await client.calls.actions.stopAIAssistant(
     *   'call_control_id',
     * );
     * ```
     */
    stopAIAssistant(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/ai_assistant_stop`, { body, ...options });
    }
    /**
     * Stop forking a call.
     *
     * **Expected Webhooks:**
     *
     * - `call.fork.stopped`
     *
     * @example
     * ```ts
     * const response = await client.calls.actions.stopForking(
     *   'call_control_id',
     * );
     * ```
     */
    stopForking(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/fork_stop`, { body, ...options });
    }
    /**
     * Stop current gather.
     *
     * **Expected Webhooks:**
     *
     * - `call.gather.ended`
     *
     * @example
     * ```ts
     * const response = await client.calls.actions.stopGather(
     *   'call_control_id',
     * );
     * ```
     */
    stopGather(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/gather_stop`, { body, ...options });
    }
    /**
     * Noise Suppression Stop (BETA)
     *
     * @example
     * ```ts
     * const response =
     *   await client.calls.actions.stopNoiseSuppression(
     *     'call_control_id',
     *   );
     * ```
     */
    stopNoiseSuppression(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/suppression_stop`, { body, ...options });
    }
    /**
     * Stop audio being played on the call.
     *
     * **Expected Webhooks:**
     *
     * - `call.playback.ended` or `call.speak.ended`
     *
     * @example
     * ```ts
     * const response = await client.calls.actions.stopPlayback(
     *   'call_control_id',
     * );
     * ```
     */
    stopPlayback(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/playback_stop`, { body, ...options });
    }
    /**
     * Stop recording the call.
     *
     * **Expected Webhooks:**
     *
     * - `call.recording.saved`
     *
     * @example
     * ```ts
     * const response = await client.calls.actions.stopRecording(
     *   'call_control_id',
     * );
     * ```
     */
    stopRecording(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/record_stop`, { body, ...options });
    }
    /**
     * Stop SIPREC session.
     *
     * **Expected Webhooks:**
     *
     * - `siprec.stopped`
     *
     * @example
     * ```ts
     * const response = await client.calls.actions.stopSiprec(
     *   'call_control_id',
     * );
     * ```
     */
    stopSiprec(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/siprec_stop`, { body, ...options });
    }
    /**
     * Stop streaming a call to a WebSocket.
     *
     * **Expected Webhooks:**
     *
     * - `streaming.stopped`
     *
     * @example
     * ```ts
     * const response = await client.calls.actions.stopStreaming(
     *   'call_control_id',
     * );
     * ```
     */
    stopStreaming(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/streaming_stop`, { body, ...options });
    }
    /**
     * Stop real-time transcription.
     *
     * @example
     * ```ts
     * const response =
     *   await client.calls.actions.stopTranscription(
     *     'call_control_id',
     *   );
     * ```
     */
    stopTranscription(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/transcription_stop`, { body, ...options });
    }
    /**
     * Switch the supervisor role for a bridged call. This allows switching between
     * different supervisor modes during an active call
     *
     * @example
     * ```ts
     * const response =
     *   await client.calls.actions.switchSupervisorRole(
     *     'call_control_id',
     *     { role: 'barge' },
     *   );
     * ```
     */
    switchSupervisorRole(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/switch_supervisor_role`, {
            body,
            ...options,
        });
    }
    /**
     * Transfer a call to a new destination. If the transfer is unsuccessful, a
     * `call.hangup` webhook for the other call (Leg B) will be sent indicating that
     * the transfer could not be completed. The original call will remain active and
     * may be issued additional commands, potentially transfering the call to an
     * alternate destination.
     *
     * **Expected Webhooks:**
     *
     * - `call.initiated`
     * - `call.bridged` to Leg B
     * - `call.answered` or `call.hangup`
     * - `call.machine.detection.ended` if `answering_machine_detection` was requested
     * - `call.machine.greeting.ended` if `answering_machine_detection` was requested
     *   to detect the end of machine greeting
     * - `call.machine.premium.detection.ended` if
     *   `answering_machine_detection=premium` was requested
     * - `call.machine.premium.greeting.ended` if `answering_machine_detection=premium`
     *   was requested and a beep was detected
     *
     * @example
     * ```ts
     * const response = await client.calls.actions.transfer(
     *   'call_control_id',
     *   { to: '+18005550100 or sip:username@sip.telnyx.com' },
     * );
     * ```
     */
    transfer(callControlID, body, options) {
        return this._client.post((0, path_1.path) `/calls/${callControlID}/actions/transfer`, { body, ...options });
    }
    /**
     * Updates client state
     *
     * @example
     * ```ts
     * const response =
     *   await client.calls.actions.updateClientState(
     *     'call_control_id',
     *     { client_state: 'aGF2ZSBhIG5pY2UgZGF5ID1d' },
     *   );
     * ```
     */
    updateClientState(callControlID, body, options) {
        return this._client.put((0, path_1.path) `/calls/${callControlID}/actions/client_state_update`, { body, ...options });
    }
}
exports.Actions = Actions;
//# sourceMappingURL=actions.js.map