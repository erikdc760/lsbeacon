// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var _AbstractPage_client;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "../internal/tslib.mjs";
import { TelnyxError } from "./error.mjs";
import { defaultParseResponse } from "../internal/parse.mjs";
import { APIPromise } from "./api-promise.mjs";
import { maybeObj } from "../internal/utils/values.mjs";
export class AbstractPage {
    constructor(client, response, body, options) {
        _AbstractPage_client.set(this, void 0);
        __classPrivateFieldSet(this, _AbstractPage_client, client, "f");
        this.options = options;
        this.response = response;
        this.body = body;
    }
    hasNextPage() {
        const items = this.getPaginatedItems();
        if (!items.length)
            return false;
        return this.nextPageRequestOptions() != null;
    }
    async getNextPage() {
        const nextOptions = this.nextPageRequestOptions();
        if (!nextOptions) {
            throw new TelnyxError('No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.');
        }
        return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
    }
    async *iterPages() {
        let page = this;
        yield page;
        while (page.hasNextPage()) {
            page = await page.getNextPage();
            yield page;
        }
    }
    async *[(_AbstractPage_client = new WeakMap(), Symbol.asyncIterator)]() {
        for await (const page of this.iterPages()) {
            for (const item of page.getPaginatedItems()) {
                yield item;
            }
        }
    }
}
/**
 * This subclass of Promise will resolve to an instantiated Page once the request completes.
 *
 * It also implements AsyncIterable to allow auto-paginating iteration on an unawaited list call, eg:
 *
 *    for await (const item of client.items.list()) {
 *      console.log(item)
 *    }
 */
export class PagePromise extends APIPromise {
    constructor(client, request, Page) {
        super(client, request, async (client, props) => new Page(client, props.response, await defaultParseResponse(client, props), props.options));
    }
    /**
     * Allow auto-paginating iteration on an unawaited list call, eg:
     *
     *    for await (const item of client.items.list()) {
     *      console.log(item)
     *    }
     */
    async *[Symbol.asyncIterator]() {
        const page = await this;
        for await (const item of page) {
            yield item;
        }
    }
}
export class DefaultFlatPagination extends AbstractPage {
    constructor(client, response, body, options) {
        super(client, response, body, options);
        this.data = body.data || [];
        this.meta = body.meta || {};
    }
    getPaginatedItems() {
        return this.data ?? [];
    }
    nextPageRequestOptions() {
        const currentPage = this.meta?.page_number ?? 1;
        if (currentPage >= this.meta?.total_pages) {
            return null;
        }
        return {
            ...this.options,
            query: {
                ...maybeObj(this.options.query),
                'page[number]': currentPage + 1,
            },
        };
    }
}
export class DefaultFlatPaginationTopLevelArray extends AbstractPage {
    constructor(client, response, body, options) {
        super(client, response, body, options);
        this.items = body || [];
    }
    getPaginatedItems() {
        return this.items ?? [];
    }
    nextPageRequestOptions() {
        const query = this.options.query;
        const currentPage = query?.['page[number]'] ?? 1;
        return {
            ...this.options,
            query: {
                ...maybeObj(this.options.query),
                'page[number]': currentPage + 1,
            },
        };
    }
}
export class DefaultPaginationForLogMessages extends AbstractPage {
    constructor(client, response, body, options) {
        super(client, response, body, options);
        this.log_messages = body.log_messages || [];
        this.meta = body.meta || {};
    }
    getPaginatedItems() {
        return this.log_messages ?? [];
    }
    nextPageRequestOptions() {
        const currentPage = this.meta?.page_number ?? 1;
        if (currentPage >= this.meta?.total_pages) {
            return null;
        }
        return {
            ...this.options,
            query: {
                ...maybeObj(this.options.query),
                'page[number]': currentPage + 1,
            },
        };
    }
}
export class DefaultPaginationForMessagingTollfree extends AbstractPage {
    constructor(client, response, body, options) {
        super(client, response, body, options);
        this.records = body.records || [];
        this.total_records = body.total_records || 0;
    }
    getPaginatedItems() {
        return this.records ?? [];
    }
    nextPageRequestOptions() {
        const query = this.options.query;
        const currentPage = query?.page ?? 1;
        if (currentPage >= this.total_records) {
            return null;
        }
        return {
            ...this.options,
            query: {
                ...maybeObj(this.options.query),
                page: currentPage + 1,
            },
        };
    }
}
export class DefaultPaginationForQueues extends AbstractPage {
    constructor(client, response, body, options) {
        super(client, response, body, options);
        this.queues = body.queues || [];
    }
    getPaginatedItems() {
        return this.queues ?? [];
    }
    nextPageRequestOptions() {
        const query = this.options.query;
        const currentPage = query?.Page ?? 1;
        return {
            ...this.options,
            query: {
                ...maybeObj(this.options.query),
                Page: currentPage + 1,
            },
        };
    }
}
export class DefaultFlatPaginationForInexplicitNumberOrders extends AbstractPage {
    constructor(client, response, body, options) {
        super(client, response, body, options);
        this.data = body.data || [];
        this.meta = body.meta || {};
    }
    getPaginatedItems() {
        return this.data ?? [];
    }
    nextPageRequestOptions() {
        const currentPage = this.meta?.page_number ?? 1;
        if (currentPage >= this.meta?.total_pages) {
            return null;
        }
        return {
            ...this.options,
            query: {
                ...maybeObj(this.options.query),
                page_number: currentPage + 1,
            },
        };
    }
}
export class PerPagePagination extends AbstractPage {
    constructor(client, response, body, options) {
        super(client, response, body, options);
        this.data = body.data || [];
        this.meta = body.meta || {};
    }
    getPaginatedItems() {
        return this.data ?? [];
    }
    nextPageRequestOptions() {
        const currentPage = this.meta?.page_number ?? 1;
        if (currentPage >= this.meta?.total_pages) {
            return null;
        }
        return {
            ...this.options,
            query: {
                ...maybeObj(this.options.query),
                page: currentPage + 1,
            },
        };
    }
}
export class PerPagePaginationV2 extends AbstractPage {
    constructor(client, response, body, options) {
        super(client, response, body, options);
        this.records = body.records || [];
        this.page = body.page;
        this.totalRecords = body.totalRecords;
    }
    getPaginatedItems() {
        return this.records ?? [];
    }
    nextPageRequestOptions() {
        const currentPage = this.page;
        if (currentPage >= this.totalRecords) {
            return null;
        }
        return {
            ...this.options,
            query: {
                ...maybeObj(this.options.query),
                page: currentPage + 1,
            },
        };
    }
}
//# sourceMappingURL=pagination.mjs.map