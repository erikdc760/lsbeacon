// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
import { APIResource } from "../../../core/resource.mjs";
import * as ExternalVettingAPI from "./external-vetting.mjs";
import { ExternalVetting, } from "./external-vetting.mjs";
import { PerPagePaginationV2 } from "../../../core/pagination.mjs";
import { buildHeaders } from "../../../internal/headers.mjs";
import { path } from "../../../internal/utils/path.mjs";
export class Brand extends APIResource {
    constructor() {
        super(...arguments);
        this.externalVetting = new ExternalVettingAPI.ExternalVetting(this._client);
    }
    /**
     * This endpoint is used to create a new brand. A brand is an entity created by The
     * Campaign Registry (TCR) that represents an organization or a company. It is this
     * entity that TCR created campaigns will be associated with. Each brand creation
     * will entail an upfront, non-refundable $4 expense.
     *
     * @example
     * ```ts
     * const telnyxBrand =
     *   await client.messaging10dlc.brand.create({
     *     country: 'US',
     *     displayName: 'ABC Mobile',
     *     email: 'email',
     *     entityType: 'PRIVATE_PROFIT',
     *     vertical: 'TECHNOLOGY',
     *   });
     * ```
     */
    create(body, options) {
        return this._client.post('/10dlc/brand', { body, ...options });
    }
    /**
     * Retrieve a brand by `brandId`.
     *
     * @example
     * ```ts
     * const brand = await client.messaging10dlc.brand.retrieve(
     *   'brandId',
     * );
     * ```
     */
    retrieve(brandID, options) {
        return this._client.get(path `/10dlc/brand/${brandID}`, options);
    }
    /**
     * Update a brand's attributes by `brandId`.
     *
     * @example
     * ```ts
     * const telnyxBrand =
     *   await client.messaging10dlc.brand.update('brandId', {
     *     country: 'US',
     *     displayName: 'ABC Mobile',
     *     email: 'email',
     *     entityType: 'PRIVATE_PROFIT',
     *     vertical: 'TECHNOLOGY',
     *   });
     * ```
     */
    update(brandID, body, options) {
        return this._client.put(path `/10dlc/brand/${brandID}`, { body, ...options });
    }
    /**
     * This endpoint is used to list all brands associated with your organization.
     *
     * @example
     * ```ts
     * // Automatically fetches more pages as needed.
     * for await (const brandListResponse of client.messaging10dlc.brand.list()) {
     *   // ...
     * }
     * ```
     */
    list(query = {}, options) {
        return this._client.getAPIList('/10dlc/brand', (PerPagePaginationV2), {
            query,
            ...options,
        });
    }
    /**
     * Delete Brand. This endpoint is used to delete a brand. Note the brand cannot be
     * deleted if it contains one or more active campaigns, the campaigns need to be
     * inactive and at least 3 months old due to billing purposes.
     *
     * @example
     * ```ts
     * await client.messaging10dlc.brand.delete('brandId');
     * ```
     */
    delete(brandID, options) {
        return this._client.delete(path `/10dlc/brand/${brandID}`, {
            ...options,
            headers: buildHeaders([{ Accept: '*/*' }, options?.headers]),
        });
    }
    /**
     * Get feedback about a brand by ID. This endpoint can be used after creating or
     * revetting a brand.
     *
     * Possible values for `.category[].id`:
     *
     * - `TAX_ID` - Data mismatch related to tax id and its associated properties.
     * - `STOCK_SYMBOL` - Non public entity registered as a public for profit entity or
     *   the stock information mismatch.
     * - `GOVERNMENT_ENTITY` - Non government entity registered as a government entity.
     *   Must be a U.S. government entity.
     * - `NONPROFIT` - Not a recognized non-profit entity. No IRS tax-exempt status
     *   found.
     * - `OTHERS` - Details of the data misrepresentation if any.
     *
     * @example
     * ```ts
     * const response =
     *   await client.messaging10dlc.brand.getFeedback('brandId');
     * ```
     */
    getFeedback(brandID, options) {
        return this._client.get(path `/10dlc/brand/feedback/${brandID}`, options);
    }
    /**
     * Resend brand 2FA email
     *
     * @example
     * ```ts
     * await client.messaging10dlc.brand.resend2faEmail('brandId');
     * ```
     */
    resend2faEmail(brandID, options) {
        return this._client.post(path `/10dlc/brand/${brandID}/2faEmail`, {
            ...options,
            headers: buildHeaders([{ Accept: '*/*' }, options?.headers]),
        });
    }
    /**
     * Query the status of an SMS OTP (One-Time Password) for Sole Proprietor brand
     * verification using the Brand ID.
     *
     * This endpoint allows you to check the delivery and verification status of an OTP
     * sent during the Sole Proprietor brand verification process by looking it up with
     * the brand ID.
     *
     * The response includes delivery status, verification dates, and detailed delivery
     * information.
     *
     * **Note:** This is an alternative to the `/10dlc/brand/smsOtp/{referenceId}`
     * endpoint when you have the Brand ID but not the reference ID.
     *
     * @example
     * ```ts
     * const response =
     *   await client.messaging10dlc.brand.retrieveSMSOtpStatus(
     *     '4b20019b-043a-78f8-0657-b3be3f4b4002',
     *   );
     * ```
     */
    retrieveSMSOtpStatus(brandID, options) {
        return this._client.get(path `/10dlc/brand/${brandID}/smsOtp`, options);
    }
    /**
     * This operation allows you to revet the brand. However, revetting is allowed once
     * after the successful brand registration and thereafter limited to once every 3
     * months.
     *
     * @example
     * ```ts
     * const telnyxBrand = await client.messaging10dlc.brand.revet(
     *   'brandId',
     * );
     * ```
     */
    revet(brandID, options) {
        return this._client.put(path `/10dlc/brand/${brandID}/revet`, options);
    }
    /**
     * Trigger or re-trigger an SMS OTP (One-Time Password) for Sole Proprietor brand
     * verification.
     *
     * **Important Notes:**
     *
     * - Only allowed for Sole Proprietor (`SOLE_PROPRIETOR`) brands
     * - Triggers generation of a one-time password sent to the `mobilePhone` number in
     *   the brand's profile
     * - Campaigns cannot be created until OTP verification is complete
     * - US/CA numbers only for real OTPs; mock brands can use non-US/CA numbers for
     *   testing
     * - Returns a `referenceId` that can be used to check OTP status via the GET
     *   `/10dlc/brand/smsOtp/{referenceId}` endpoint
     *
     * **Use Cases:**
     *
     * - Initial OTP trigger after Sole Proprietor brand creation
     * - Re-triggering OTP if the user didn't receive or needs a new code
     *
     * @example
     * ```ts
     * const response =
     *   await client.messaging10dlc.brand.triggerSMSOtp(
     *     '4b20019b-043a-78f8-0657-b3be3f4b4002',
     *     {
     *       pinSms: 'Your PIN is @OTP_PIN@',
     *       successSms: 'Verification successful!',
     *     },
     *   );
     * ```
     */
    triggerSMSOtp(brandID, body, options) {
        return this._client.post(path `/10dlc/brand/${brandID}/smsOtp`, { body, ...options });
    }
    /**
     * Verify the SMS OTP (One-Time Password) for Sole Proprietor brand verification.
     *
     * **Verification Flow:**
     *
     * 1. User receives OTP via SMS after triggering
     * 2. User submits the OTP pin through this endpoint
     * 3. Upon successful verification:
     *    - A `BRAND_OTP_VERIFIED` webhook event is sent to the CSP
     *    - The brand's `identityStatus` changes to `VERIFIED`
     *    - Campaigns can now be created for this brand
     *
     * **Error Handling:**
     *
     * Provides proper error responses for:
     *
     * - Invalid OTP pins
     * - Expired OTPs
     * - OTP verification failures
     *
     * @example
     * ```ts
     * await client.messaging10dlc.brand.verifySMSOtp(
     *   '4b20019b-043a-78f8-0657-b3be3f4b4002',
     *   { otpPin: '123456' },
     * );
     * ```
     */
    verifySMSOtp(brandID, body, options) {
        return this._client.put(path `/10dlc/brand/${brandID}/smsOtp`, {
            body,
            ...options,
            headers: buildHeaders([{ Accept: '*/*' }, options?.headers]),
        });
    }
}
Brand.ExternalVetting = ExternalVetting;
//# sourceMappingURL=brand.mjs.map