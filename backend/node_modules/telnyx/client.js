"use strict";
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var _Telnyx_instances, _a, _Telnyx_encoder, _Telnyx_baseURLOverridden;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Telnyx = void 0;
const tslib_1 = require("./internal/tslib.js");
const uuid_1 = require("./internal/utils/uuid.js");
const values_1 = require("./internal/utils/values.js");
const sleep_1 = require("./internal/utils/sleep.js");
const errors_1 = require("./internal/errors.js");
const detect_platform_1 = require("./internal/detect-platform.js");
const Shims = tslib_1.__importStar(require("./internal/shims.js"));
const Opts = tslib_1.__importStar(require("./internal/request-options.js"));
const qs = tslib_1.__importStar(require("./internal/qs/index.js"));
const version_1 = require("./version.js");
const Errors = tslib_1.__importStar(require("./core/error.js"));
const Pagination = tslib_1.__importStar(require("./core/pagination.js"));
const Uploads = tslib_1.__importStar(require("./core/uploads.js"));
const API = tslib_1.__importStar(require("./resources/index.js"));
const api_promise_1 = require("./core/api-promise.js");
const access_ip_address_1 = require("./resources/access-ip-address.js");
const access_ip_ranges_1 = require("./resources/access-ip-ranges.js");
const advanced_orders_1 = require("./resources/advanced-orders.js");
const audit_events_1 = require("./resources/audit-events.js");
const authentication_providers_1 = require("./resources/authentication-providers.js");
const available_phone_number_blocks_1 = require("./resources/available-phone-number-blocks.js");
const available_phone_numbers_1 = require("./resources/available-phone-numbers.js");
const balance_1 = require("./resources/balance.js");
const billing_groups_1 = require("./resources/billing-groups.js");
const bulk_sim_card_actions_1 = require("./resources/bulk-sim-card-actions.js");
const call_control_applications_1 = require("./resources/call-control-applications.js");
const call_events_1 = require("./resources/call-events.js");
const channel_zones_1 = require("./resources/channel-zones.js");
const charges_breakdown_1 = require("./resources/charges-breakdown.js");
const charges_summary_1 = require("./resources/charges-summary.js");
const comments_1 = require("./resources/comments.js");
const connections_1 = require("./resources/connections.js");
const country_coverage_1 = require("./resources/country-coverage.js");
const custom_storage_credentials_1 = require("./resources/custom-storage-credentials.js");
const customer_service_records_1 = require("./resources/customer-service-records.js");
const detail_records_1 = require("./resources/detail-records.js");
const dialogflow_connections_1 = require("./resources/dialogflow-connections.js");
const document_links_1 = require("./resources/document-links.js");
const documents_1 = require("./resources/documents.js");
const dynamic_emergency_addresses_1 = require("./resources/dynamic-emergency-addresses.js");
const dynamic_emergency_endpoints_1 = require("./resources/dynamic-emergency-endpoints.js");
const fax_applications_1 = require("./resources/fax-applications.js");
const fqdn_connections_1 = require("./resources/fqdn-connections.js");
const fqdns_1 = require("./resources/fqdns.js");
const global_ip_allowed_ports_1 = require("./resources/global-ip-allowed-ports.js");
const global_ip_assignment_health_1 = require("./resources/global-ip-assignment-health.js");
const global_ip_assignments_1 = require("./resources/global-ip-assignments.js");
const global_ip_assignments_usage_1 = require("./resources/global-ip-assignments-usage.js");
const global_ip_health_check_types_1 = require("./resources/global-ip-health-check-types.js");
const global_ip_health_checks_1 = require("./resources/global-ip-health-checks.js");
const global_ip_latency_1 = require("./resources/global-ip-latency.js");
const global_ip_protocols_1 = require("./resources/global-ip-protocols.js");
const global_ip_usage_1 = require("./resources/global-ip-usage.js");
const global_ips_1 = require("./resources/global-ips.js");
const inbound_channels_1 = require("./resources/inbound-channels.js");
const inexplicit_number_orders_1 = require("./resources/inexplicit-number-orders.js");
const integration_secrets_1 = require("./resources/integration-secrets.js");
const inventory_coverage_1 = require("./resources/inventory-coverage.js");
const invoices_1 = require("./resources/invoices.js");
const ip_connections_1 = require("./resources/ip-connections.js");
const ips_1 = require("./resources/ips.js");
const ledger_billing_group_reports_1 = require("./resources/ledger-billing-group-reports.js");
const list_1 = require("./resources/list.js");
const media_1 = require("./resources/media.js");
const messaging_hosted_numbers_1 = require("./resources/messaging-hosted-numbers.js");
const messaging_numbers_bulk_updates_1 = require("./resources/messaging-numbers-bulk-updates.js");
const messaging_optouts_1 = require("./resources/messaging-optouts.js");
const messaging_url_domains_1 = require("./resources/messaging-url-domains.js");
const mobile_network_operators_1 = require("./resources/mobile-network-operators.js");
const mobile_push_credentials_1 = require("./resources/mobile-push-credentials.js");
const mobile_voice_connections_1 = require("./resources/mobile-voice-connections.js");
const network_coverage_1 = require("./resources/network-coverage.js");
const notification_channels_1 = require("./resources/notification-channels.js");
const notification_event_conditions_1 = require("./resources/notification-event-conditions.js");
const notification_events_1 = require("./resources/notification-events.js");
const notification_profiles_1 = require("./resources/notification-profiles.js");
const notification_settings_1 = require("./resources/notification-settings.js");
const number_block_orders_1 = require("./resources/number-block-orders.js");
const number_lookup_1 = require("./resources/number-lookup.js");
const number_order_phone_numbers_1 = require("./resources/number-order-phone-numbers.js");
const number_orders_1 = require("./resources/number-orders.js");
const numbers_features_1 = require("./resources/numbers-features.js");
const oauth_1 = require("./resources/oauth.js");
const oauth_clients_1 = require("./resources/oauth-clients.js");
const oauth_grants_1 = require("./resources/oauth-grants.js");
const ota_updates_1 = require("./resources/ota-updates.js");
const outbound_voice_profiles_1 = require("./resources/outbound-voice-profiles.js");
const phone_numbers_regulatory_requirements_1 = require("./resources/phone-numbers-regulatory-requirements.js");
const portability_checks_1 = require("./resources/portability-checks.js");
const porting_phone_numbers_1 = require("./resources/porting-phone-numbers.js");
const private_wireless_gateways_1 = require("./resources/private-wireless-gateways.js");
const public_internet_gateways_1 = require("./resources/public-internet-gateways.js");
const rcs_agents_1 = require("./resources/rcs-agents.js");
const recording_transcriptions_1 = require("./resources/recording-transcriptions.js");
const regions_1 = require("./resources/regions.js");
const regulatory_requirements_1 = require("./resources/regulatory-requirements.js");
const requirement_groups_1 = require("./resources/requirement-groups.js");
const requirement_types_1 = require("./resources/requirement-types.js");
const requirements_1 = require("./resources/requirements.js");
const room_compositions_1 = require("./resources/room-compositions.js");
const room_participants_1 = require("./resources/room-participants.js");
const room_recordings_1 = require("./resources/room-recordings.js");
const seti_1 = require("./resources/seti.js");
const short_codes_1 = require("./resources/short-codes.js");
const sim_card_data_usage_notifications_1 = require("./resources/sim-card-data-usage-notifications.js");
const sim_card_order_preview_1 = require("./resources/sim-card-order-preview.js");
const sim_card_orders_1 = require("./resources/sim-card-orders.js");
const siprec_connectors_1 = require("./resources/siprec-connectors.js");
const speech_to_text_1 = require("./resources/speech-to-text.js");
const sub_number_orders_1 = require("./resources/sub-number-orders.js");
const sub_number_orders_report_1 = require("./resources/sub-number-orders-report.js");
const telephony_credentials_1 = require("./resources/telephony-credentials.js");
const texml_applications_1 = require("./resources/texml-applications.js");
const text_to_speech_1 = require("./resources/text-to-speech.js");
const usage_reports_1 = require("./resources/usage-reports.js");
const user_addresses_1 = require("./resources/user-addresses.js");
const user_tags_1 = require("./resources/user-tags.js");
const verify_profiles_1 = require("./resources/verify-profiles.js");
const virtual_cross_connects_1 = require("./resources/virtual-cross-connects.js");
const virtual_cross_connects_coverage_1 = require("./resources/virtual-cross-connects-coverage.js");
const webhook_deliveries_1 = require("./resources/webhook-deliveries.js");
const webhooks_1 = require("./resources/webhooks.js");
const well_known_1 = require("./resources/well-known.js");
const wireguard_interfaces_1 = require("./resources/wireguard-interfaces.js");
const wireguard_peers_1 = require("./resources/wireguard-peers.js");
const wireless_blocklist_values_1 = require("./resources/wireless-blocklist-values.js");
const wireless_blocklists_1 = require("./resources/wireless-blocklists.js");
const actions_1 = require("./resources/actions/actions.js");
const addresses_1 = require("./resources/addresses/addresses.js");
const ai_1 = require("./resources/ai/ai.js");
const bundle_pricing_1 = require("./resources/bundle-pricing/bundle-pricing.js");
const calls_1 = require("./resources/calls/calls.js");
const conferences_1 = require("./resources/conferences/conferences.js");
const credential_connections_1 = require("./resources/credential-connections/credential-connections.js");
const external_connections_1 = require("./resources/external-connections/external-connections.js");
const faxes_1 = require("./resources/faxes/faxes.js");
const legacy_1 = require("./resources/legacy/legacy.js");
const managed_accounts_1 = require("./resources/managed-accounts/managed-accounts.js");
const messages_1 = require("./resources/messages/messages.js");
const messaging_10dlc_1 = require("./resources/messaging-10dlc/messaging-10dlc.js");
const messaging_hosted_number_orders_1 = require("./resources/messaging-hosted-number-orders/messaging-hosted-number-orders.js");
const messaging_profiles_1 = require("./resources/messaging-profiles/messaging-profiles.js");
const messaging_tollfree_1 = require("./resources/messaging-tollfree/messaging-tollfree.js");
const messaging_1 = require("./resources/messaging/messaging.js");
const mobile_phone_numbers_1 = require("./resources/mobile-phone-numbers/mobile-phone-numbers.js");
const networks_1 = require("./resources/networks/networks.js");
const number_reservations_1 = require("./resources/number-reservations/number-reservations.js");
const operator_connect_1 = require("./resources/operator-connect/operator-connect.js");
const organizations_1 = require("./resources/organizations/organizations.js");
const payment_1 = require("./resources/payment/payment.js");
const phone_number_blocks_1 = require("./resources/phone-number-blocks/phone-number-blocks.js");
const phone_numbers_1 = require("./resources/phone-numbers/phone-numbers.js");
const porting_orders_1 = require("./resources/porting-orders/porting-orders.js");
const porting_1 = require("./resources/porting/porting.js");
const portouts_1 = require("./resources/portouts/portouts.js");
const queues_1 = require("./resources/queues/queues.js");
const recordings_1 = require("./resources/recordings/recordings.js");
const reports_1 = require("./resources/reports/reports.js");
const rooms_1 = require("./resources/rooms/rooms.js");
const sim_card_groups_1 = require("./resources/sim-card-groups/sim-card-groups.js");
const sim_cards_1 = require("./resources/sim-cards/sim-cards.js");
const storage_1 = require("./resources/storage/storage.js");
const texml_1 = require("./resources/texml/texml.js");
const verifications_1 = require("./resources/verifications/verifications.js");
const verified_numbers_1 = require("./resources/verified-numbers/verified-numbers.js");
const wireless_1 = require("./resources/wireless/wireless.js");
const headers_1 = require("./internal/headers.js");
const base64_1 = require("./internal/utils/base64.js");
const env_1 = require("./internal/utils/env.js");
const log_1 = require("./internal/utils/log.js");
const values_2 = require("./internal/utils/values.js");
/**
 * API Client for interfacing with the Telnyx API.
 */
class Telnyx {
    /**
     * API Client for interfacing with the Telnyx API.
     *
     * @param {string | null | undefined} [opts.apiKey=process.env['TELNYX_API_KEY'] ?? null]
     * @param {string | null | undefined} [opts.publicKey=process.env['TELNYX_PUBLIC_KEY'] ?? null]
     * @param {string | null | undefined} [opts.clientID=process.env['TELNYX_CLIENT_ID'] ?? null]
     * @param {string | null | undefined} [opts.clientSecret=process.env['TELNYX_CLIENT_SECRET'] ?? null]
     * @param {string} [opts.baseURL=process.env['TELNYX_BASE_URL'] ?? https://api.telnyx.com/v2] - Override the default base URL for the API.
     * @param {number} [opts.timeout=1 minute] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
     * @param {MergedRequestInit} [opts.fetchOptions] - Additional `RequestInit` options to be passed to `fetch` calls.
     * @param {Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
     * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
     * @param {HeadersLike} opts.defaultHeaders - Default headers to include with every request to the API.
     * @param {BuiltinRecord<string, string | undefined>} opts.defaultQuery - Default query parameters to include with every request to the API.
     */
    constructor({ baseURL = (0, env_1.readEnv)('TELNYX_BASE_URL'), apiKey = (0, env_1.readEnv)('TELNYX_API_KEY') ?? null, publicKey = (0, env_1.readEnv)('TELNYX_PUBLIC_KEY') ?? null, clientID = (0, env_1.readEnv)('TELNYX_CLIENT_ID') ?? null, clientSecret = (0, env_1.readEnv)('TELNYX_CLIENT_SECRET') ?? null, ...opts } = {}) {
        _Telnyx_instances.add(this);
        _Telnyx_encoder.set(this, void 0);
        this.legacy = new API.Legacy(this);
        this.oauth = new API.OAuth(this);
        this.oauthClients = new API.OAuthClients(this);
        this.oauthGrants = new API.OAuthGrants(this);
        this.webhooks = new API.Webhooks(this);
        this.accessIPAddress = new API.AccessIPAddress(this);
        this.accessIPRanges = new API.AccessIPRanges(this);
        this.actions = new API.Actions(this);
        this.addresses = new API.Addresses(this);
        this.advancedOrders = new API.AdvancedOrders(this);
        this.ai = new API.AI(this);
        this.auditEvents = new API.AuditEvents(this);
        this.authenticationProviders = new API.AuthenticationProviders(this);
        this.availablePhoneNumberBlocks = new API.AvailablePhoneNumberBlocks(this);
        this.availablePhoneNumbers = new API.AvailablePhoneNumbers(this);
        this.balance = new API.Balance(this);
        this.billingGroups = new API.BillingGroups(this);
        this.bulkSimCardActions = new API.BulkSimCardActions(this);
        this.bundlePricing = new API.BundlePricing(this);
        this.callControlApplications = new API.CallControlApplications(this);
        this.callEvents = new API.CallEvents(this);
        this.calls = new API.Calls(this);
        this.channelZones = new API.ChannelZones(this);
        this.chargesBreakdown = new API.ChargesBreakdown(this);
        this.chargesSummary = new API.ChargesSummary(this);
        this.comments = new API.Comments(this);
        this.conferences = new API.Conferences(this);
        this.connections = new API.Connections(this);
        this.countryCoverage = new API.CountryCoverage(this);
        this.credentialConnections = new API.CredentialConnections(this);
        this.customStorageCredentials = new API.CustomStorageCredentials(this);
        this.customerServiceRecords = new API.CustomerServiceRecords(this);
        this.detailRecords = new API.DetailRecords(this);
        this.dialogflowConnections = new API.DialogflowConnections(this);
        this.documentLinks = new API.DocumentLinks(this);
        this.documents = new API.Documents(this);
        this.dynamicEmergencyAddresses = new API.DynamicEmergencyAddresses(this);
        this.dynamicEmergencyEndpoints = new API.DynamicEmergencyEndpoints(this);
        this.externalConnections = new API.ExternalConnections(this);
        this.faxApplications = new API.FaxApplications(this);
        this.faxes = new API.Faxes(this);
        this.fqdnConnections = new API.FqdnConnections(this);
        this.fqdns = new API.Fqdns(this);
        this.globalIPAllowedPorts = new API.GlobalIPAllowedPorts(this);
        this.globalIPAssignmentHealth = new API.GlobalIPAssignmentHealth(this);
        this.globalIPAssignments = new API.GlobalIPAssignments(this);
        this.globalIPAssignmentsUsage = new API.GlobalIPAssignmentsUsage(this);
        this.globalIPHealthCheckTypes = new API.GlobalIPHealthCheckTypes(this);
        this.globalIPHealthChecks = new API.GlobalIPHealthChecks(this);
        this.globalIPLatency = new API.GlobalIPLatency(this);
        this.globalIPProtocols = new API.GlobalIPProtocols(this);
        this.globalIPUsage = new API.GlobalIPUsage(this);
        this.globalIPs = new API.GlobalIPs(this);
        this.inboundChannels = new API.InboundChannels(this);
        this.integrationSecrets = new API.IntegrationSecrets(this);
        this.inventoryCoverage = new API.InventoryCoverage(this);
        this.invoices = new API.Invoices(this);
        this.ipConnections = new API.IPConnections(this);
        this.ips = new API.IPs(this);
        this.ledgerBillingGroupReports = new API.LedgerBillingGroupReports(this);
        this.list = new API.List(this);
        this.managedAccounts = new API.ManagedAccounts(this);
        this.media = new API.Media(this);
        this.messages = new API.Messages(this);
        this.messaging = new API.Messaging(this);
        this.messagingHostedNumberOrders = new API.MessagingHostedNumberOrders(this);
        this.messagingHostedNumbers = new API.MessagingHostedNumbers(this);
        this.messagingNumbersBulkUpdates = new API.MessagingNumbersBulkUpdates(this);
        this.messagingOptouts = new API.MessagingOptouts(this);
        this.messagingProfiles = new API.MessagingProfiles(this);
        this.messagingTollfree = new API.MessagingTollfree(this);
        this.messagingURLDomains = new API.MessagingURLDomains(this);
        this.mobileNetworkOperators = new API.MobileNetworkOperators(this);
        this.mobilePushCredentials = new API.MobilePushCredentials(this);
        this.networkCoverage = new API.NetworkCoverage(this);
        this.networks = new API.Networks(this);
        this.notificationChannels = new API.NotificationChannels(this);
        this.notificationEventConditions = new API.NotificationEventConditions(this);
        this.notificationEvents = new API.NotificationEvents(this);
        this.notificationProfiles = new API.NotificationProfiles(this);
        this.notificationSettings = new API.NotificationSettings(this);
        this.numberBlockOrders = new API.NumberBlockOrders(this);
        this.numberLookup = new API.NumberLookup(this);
        this.numberOrderPhoneNumbers = new API.NumberOrderPhoneNumbers(this);
        this.numberOrders = new API.NumberOrders(this);
        this.numberReservations = new API.NumberReservations(this);
        this.numbersFeatures = new API.NumbersFeatures(this);
        this.operatorConnect = new API.OperatorConnect(this);
        this.otaUpdates = new API.OtaUpdates(this);
        this.outboundVoiceProfiles = new API.OutboundVoiceProfiles(this);
        this.payment = new API.Payment(this);
        this.phoneNumberBlocks = new API.PhoneNumberBlocks(this);
        this.phoneNumbers = new API.PhoneNumbers(this);
        this.phoneNumbersRegulatoryRequirements = new API.PhoneNumbersRegulatoryRequirements(this);
        this.portabilityChecks = new API.PortabilityChecks(this);
        this.porting = new API.Porting(this);
        this.portingOrders = new API.PortingOrders(this);
        this.portingPhoneNumbers = new API.PortingPhoneNumbers(this);
        this.portouts = new API.Portouts(this);
        this.privateWirelessGateways = new API.PrivateWirelessGateways(this);
        this.publicInternetGateways = new API.PublicInternetGateways(this);
        this.queues = new API.Queues(this);
        this.rcsAgents = new API.RcsAgents(this);
        this.recordingTranscriptions = new API.RecordingTranscriptions(this);
        this.recordings = new API.Recordings(this);
        this.regions = new API.Regions(this);
        this.regulatoryRequirements = new API.RegulatoryRequirements(this);
        this.reports = new API.Reports(this);
        this.requirementGroups = new API.RequirementGroups(this);
        this.requirementTypes = new API.RequirementTypes(this);
        this.requirements = new API.Requirements(this);
        this.roomCompositions = new API.RoomCompositions(this);
        this.roomParticipants = new API.RoomParticipants(this);
        this.roomRecordings = new API.RoomRecordings(this);
        this.rooms = new API.Rooms(this);
        this.seti = new API.Seti(this);
        this.shortCodes = new API.ShortCodes(this);
        this.simCardDataUsageNotifications = new API.SimCardDataUsageNotifications(this);
        this.simCardGroups = new API.SimCardGroups(this);
        this.simCardOrderPreview = new API.SimCardOrderPreview(this);
        this.simCardOrders = new API.SimCardOrders(this);
        this.simCards = new API.SimCards(this);
        this.siprecConnectors = new API.SiprecConnectors(this);
        this.storage = new API.Storage(this);
        this.subNumberOrders = new API.SubNumberOrders(this);
        this.subNumberOrdersReport = new API.SubNumberOrdersReport(this);
        this.telephonyCredentials = new API.TelephonyCredentials(this);
        this.texml = new API.Texml(this);
        this.texmlApplications = new API.TexmlApplications(this);
        this.textToSpeech = new API.TextToSpeech(this);
        this.usageReports = new API.UsageReports(this);
        this.userAddresses = new API.UserAddresses(this);
        this.userTags = new API.UserTags(this);
        this.verifications = new API.Verifications(this);
        this.verifiedNumbers = new API.VerifiedNumbers(this);
        this.verifyProfiles = new API.VerifyProfiles(this);
        this.virtualCrossConnects = new API.VirtualCrossConnects(this);
        this.virtualCrossConnectsCoverage = new API.VirtualCrossConnectsCoverage(this);
        this.webhookDeliveries = new API.WebhookDeliveries(this);
        this.wireguardInterfaces = new API.WireguardInterfaces(this);
        this.wireguardPeers = new API.WireguardPeers(this);
        this.wireless = new API.Wireless(this);
        this.wirelessBlocklistValues = new API.WirelessBlocklistValues(this);
        this.wirelessBlocklists = new API.WirelessBlocklists(this);
        this.wellKnown = new API.WellKnown(this);
        this.inexplicitNumberOrders = new API.InexplicitNumberOrders(this);
        this.mobilePhoneNumbers = new API.MobilePhoneNumbers(this);
        this.mobileVoiceConnections = new API.MobileVoiceConnections(this);
        this.messaging10dlc = new API.Messaging10dlc(this);
        this.speechToText = new API.SpeechToText(this);
        this.organizations = new API.Organizations(this);
        const options = {
            apiKey,
            publicKey,
            clientID,
            clientSecret,
            ...opts,
            baseURL: baseURL || `https://api.telnyx.com/v2`,
        };
        this.baseURL = options.baseURL;
        this.timeout = options.timeout ?? _a.DEFAULT_TIMEOUT /* 1 minute */;
        this.logger = options.logger ?? console;
        const defaultLogLevel = 'warn';
        // Set default logLevel early so that we can log a warning in parseLogLevel.
        this.logLevel = defaultLogLevel;
        this.logLevel =
            (0, log_1.parseLogLevel)(options.logLevel, 'ClientOptions.logLevel', this) ??
                (0, log_1.parseLogLevel)((0, env_1.readEnv)('TELNYX_LOG'), "process.env['TELNYX_LOG']", this) ??
                defaultLogLevel;
        this.fetchOptions = options.fetchOptions;
        this.maxRetries = options.maxRetries ?? 2;
        this.fetch = options.fetch ?? Shims.getDefaultFetch();
        tslib_1.__classPrivateFieldSet(this, _Telnyx_encoder, Opts.FallbackEncoder, "f");
        this._options = options;
        this.apiKey = apiKey;
        this.publicKey = publicKey;
        this.clientID = clientID;
        this.clientSecret = clientSecret;
    }
    /**
     * Create a new client instance re-using the same options given to the current client with optional overriding.
     */
    withOptions(options) {
        const client = new this.constructor({
            ...this._options,
            baseURL: this.baseURL,
            maxRetries: this.maxRetries,
            timeout: this.timeout,
            logger: this.logger,
            logLevel: this.logLevel,
            fetch: this.fetch,
            fetchOptions: this.fetchOptions,
            apiKey: this.apiKey,
            publicKey: this.publicKey,
            clientID: this.clientID,
            clientSecret: this.clientSecret,
            ...options,
        });
        client.oauthClientAuthState = this.oauthClientAuthState;
        return client;
    }
    defaultQuery() {
        return this._options.defaultQuery;
    }
    validateHeaders({ values, nulls }) {
        return;
    }
    async authHeaders(opts) {
        return (0, headers_1.buildHeaders)([await this.bearerAuth(opts), await this.oauthClientAuth(opts)]);
    }
    async bearerAuth(opts) {
        if (this.apiKey == null) {
            return undefined;
        }
        return (0, headers_1.buildHeaders)([{ Authorization: `Bearer ${this.apiKey}` }]);
    }
    async oauthClientAuth(opts) {
        if (!this.clientID || !this.clientSecret) {
            return undefined;
        }
        // Invalidate the cache if the token is expired
        if (this.oauthClientAuthState && +(await this.oauthClientAuthState.promise).expires_at < Date.now()) {
            this.oauthClientAuthState = undefined;
        }
        // Invalidate the cache if the relevant state has been changed
        if (this.oauthClientAuthState &&
            this.oauthClientAuthState.clientID !== this.clientID &&
            this.oauthClientAuthState.clientSecret !== this.clientSecret) {
            this.oauthClientAuthState = undefined;
        }
        if (!this.oauthClientAuthState) {
            this.oauthClientAuthState = {
                promise: this.fetch(this.buildURL('https://api.telnyx.com/v2/oauth/token', {}), {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        Authorization: `Basic ${(0, base64_1.toBase64)(`${this.clientID}:${this.clientSecret}`)}`,
                    },
                    body: 'grant_type=client_credentials',
                }).then(async (res) => {
                    if (!res.ok) {
                        const errText = await res.text().catch(() => '');
                        const errJSON = errText ? (0, values_1.safeJSON)(errText) : undefined;
                        const errMessage = errJSON ? undefined : errText;
                        throw this.makeStatusError(res.status, errJSON, errMessage, res.headers);
                    }
                    const json = (await res.json());
                    const now = new Date();
                    now.setSeconds(now.getSeconds() + json.expires_in);
                    return { ...json, expires_at: now };
                }),
                clientID: this.clientID,
                clientSecret: this.clientSecret,
            };
        }
        const token = await this.oauthClientAuthState.promise;
        return (0, headers_1.buildHeaders)([{ Authorization: `Bearer ${token.access_token}` }]);
    }
    stringifyQuery(query) {
        return qs.stringify(query, { arrayFormat: 'comma' });
    }
    getUserAgent() {
        return `${this.constructor.name}/JS ${version_1.VERSION}`;
    }
    defaultIdempotencyKey() {
        return `stainless-node-retry-${(0, uuid_1.uuid4)()}`;
    }
    makeStatusError(status, error, message, headers) {
        return Errors.APIError.generate(status, error, message, headers);
    }
    buildURL(path, query, defaultBaseURL) {
        const baseURL = (!tslib_1.__classPrivateFieldGet(this, _Telnyx_instances, "m", _Telnyx_baseURLOverridden).call(this) && defaultBaseURL) || this.baseURL;
        const url = (0, values_1.isAbsoluteURL)(path) ?
            new URL(path)
            : new URL(baseURL + (baseURL.endsWith('/') && path.startsWith('/') ? path.slice(1) : path));
        const defaultQuery = this.defaultQuery();
        if (!(0, values_2.isEmptyObj)(defaultQuery)) {
            query = { ...defaultQuery, ...query };
        }
        if (typeof query === 'object' && query && !Array.isArray(query)) {
            url.search = this.stringifyQuery(query);
        }
        return url.toString();
    }
    /**
     * Used as a callback for mutating the given `FinalRequestOptions` object.
     */
    async prepareOptions(options) { }
    /**
     * Used as a callback for mutating the given `RequestInit` object.
     *
     * This is useful for cases where you want to add certain headers based off of
     * the request properties, e.g. `method` or `url`.
     */
    async prepareRequest(request, { url, options }) { }
    get(path, opts) {
        return this.methodRequest('get', path, opts);
    }
    post(path, opts) {
        return this.methodRequest('post', path, opts);
    }
    patch(path, opts) {
        return this.methodRequest('patch', path, opts);
    }
    put(path, opts) {
        return this.methodRequest('put', path, opts);
    }
    delete(path, opts) {
        return this.methodRequest('delete', path, opts);
    }
    methodRequest(method, path, opts) {
        return this.request(Promise.resolve(opts).then((opts) => {
            return { method, path, ...opts };
        }));
    }
    request(options, remainingRetries = null) {
        return new api_promise_1.APIPromise(this, this.makeRequest(options, remainingRetries, undefined));
    }
    async makeRequest(optionsInput, retriesRemaining, retryOfRequestLogID) {
        const options = await optionsInput;
        const maxRetries = options.maxRetries ?? this.maxRetries;
        if (retriesRemaining == null) {
            retriesRemaining = maxRetries;
        }
        await this.prepareOptions(options);
        const { req, url, timeout } = await this.buildRequest(options, {
            retryCount: maxRetries - retriesRemaining,
        });
        await this.prepareRequest(req, { url, options });
        /** Not an API request ID, just for correlating local log entries. */
        const requestLogID = 'log_' + ((Math.random() * (1 << 24)) | 0).toString(16).padStart(6, '0');
        const retryLogStr = retryOfRequestLogID === undefined ? '' : `, retryOf: ${retryOfRequestLogID}`;
        const startTime = Date.now();
        (0, log_1.loggerFor)(this).debug(`[${requestLogID}] sending request`, (0, log_1.formatRequestDetails)({
            retryOfRequestLogID,
            method: options.method,
            url,
            options,
            headers: req.headers,
        }));
        if (options.signal?.aborted) {
            throw new Errors.APIUserAbortError();
        }
        const controller = new AbortController();
        const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(errors_1.castToError);
        const headersTime = Date.now();
        if (response instanceof globalThis.Error) {
            const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;
            if (options.signal?.aborted) {
                throw new Errors.APIUserAbortError();
            }
            // detect native connection timeout errors
            // deno throws "TypeError: error sending request for url (https://example/): client error (Connect): tcp connect error: Operation timed out (os error 60): Operation timed out (os error 60)"
            // undici throws "TypeError: fetch failed" with cause "ConnectTimeoutError: Connect Timeout Error (attempted address: example:443, timeout: 1ms)"
            // others do not provide enough information to distinguish timeouts from other connection errors
            const isTimeout = (0, errors_1.isAbortError)(response) ||
                /timed? ?out/i.test(String(response) + ('cause' in response ? String(response.cause) : ''));
            if (retriesRemaining) {
                (0, log_1.loggerFor)(this).info(`[${requestLogID}] connection ${isTimeout ? 'timed out' : 'failed'} - ${retryMessage}`);
                (0, log_1.loggerFor)(this).debug(`[${requestLogID}] connection ${isTimeout ? 'timed out' : 'failed'} (${retryMessage})`, (0, log_1.formatRequestDetails)({
                    retryOfRequestLogID,
                    url,
                    durationMs: headersTime - startTime,
                    message: response.message,
                }));
                return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID);
            }
            (0, log_1.loggerFor)(this).info(`[${requestLogID}] connection ${isTimeout ? 'timed out' : 'failed'} - error; no more retries left`);
            (0, log_1.loggerFor)(this).debug(`[${requestLogID}] connection ${isTimeout ? 'timed out' : 'failed'} (error; no more retries left)`, (0, log_1.formatRequestDetails)({
                retryOfRequestLogID,
                url,
                durationMs: headersTime - startTime,
                message: response.message,
            }));
            if (isTimeout) {
                throw new Errors.APIConnectionTimeoutError();
            }
            throw new Errors.APIConnectionError({ cause: response });
        }
        const responseInfo = `[${requestLogID}${retryLogStr}] ${req.method} ${url} ${response.ok ? 'succeeded' : 'failed'} with status ${response.status} in ${headersTime - startTime}ms`;
        if (!response.ok) {
            const shouldRetry = await this.shouldRetry(response);
            if (retriesRemaining && shouldRetry) {
                const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;
                // We don't need the body of this response.
                await Shims.CancelReadableStream(response.body);
                (0, log_1.loggerFor)(this).info(`${responseInfo} - ${retryMessage}`);
                (0, log_1.loggerFor)(this).debug(`[${requestLogID}] response error (${retryMessage})`, (0, log_1.formatRequestDetails)({
                    retryOfRequestLogID,
                    url: response.url,
                    status: response.status,
                    headers: response.headers,
                    durationMs: headersTime - startTime,
                }));
                return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID, response.headers);
            }
            const retryMessage = shouldRetry ? `error; no more retries left` : `error; not retryable`;
            (0, log_1.loggerFor)(this).info(`${responseInfo} - ${retryMessage}`);
            const errText = await response.text().catch((err) => (0, errors_1.castToError)(err).message);
            const errJSON = (0, values_1.safeJSON)(errText);
            const errMessage = errJSON ? undefined : errText;
            (0, log_1.loggerFor)(this).debug(`[${requestLogID}] response error (${retryMessage})`, (0, log_1.formatRequestDetails)({
                retryOfRequestLogID,
                url: response.url,
                status: response.status,
                headers: response.headers,
                message: errMessage,
                durationMs: Date.now() - startTime,
            }));
            const err = this.makeStatusError(response.status, errJSON, errMessage, response.headers);
            throw err;
        }
        (0, log_1.loggerFor)(this).info(responseInfo);
        (0, log_1.loggerFor)(this).debug(`[${requestLogID}] response start`, (0, log_1.formatRequestDetails)({
            retryOfRequestLogID,
            url: response.url,
            status: response.status,
            headers: response.headers,
            durationMs: headersTime - startTime,
        }));
        return { response, options, controller, requestLogID, retryOfRequestLogID, startTime };
    }
    getAPIList(path, Page, opts) {
        return this.requestAPIList(Page, { method: 'get', path, ...opts });
    }
    requestAPIList(Page, options) {
        const request = this.makeRequest(options, null, undefined);
        return new Pagination.PagePromise(this, request, Page);
    }
    async fetchWithTimeout(url, init, ms, controller) {
        const { signal, method, ...options } = init || {};
        const abort = controller.abort.bind(controller);
        if (signal)
            signal.addEventListener('abort', abort, { once: true });
        const timeout = setTimeout(abort, ms);
        const isReadableBody = (globalThis.ReadableStream && options.body instanceof globalThis.ReadableStream) ||
            (typeof options.body === 'object' && options.body !== null && Symbol.asyncIterator in options.body);
        const fetchOptions = {
            signal: controller.signal,
            ...(isReadableBody ? { duplex: 'half' } : {}),
            method: 'GET',
            ...options,
        };
        if (method) {
            // Custom methods like 'patch' need to be uppercased
            // See https://github.com/nodejs/undici/issues/2294
            fetchOptions.method = method.toUpperCase();
        }
        try {
            // use undefined this binding; fetch errors if bound to something else in browser/cloudflare
            return await this.fetch.call(undefined, url, fetchOptions);
        }
        finally {
            clearTimeout(timeout);
        }
    }
    async shouldRetry(response) {
        // Note this is not a standard header.
        const shouldRetryHeader = response.headers.get('x-should-retry');
        // If the server explicitly says whether or not to retry, obey.
        if (shouldRetryHeader === 'true')
            return true;
        if (shouldRetryHeader === 'false')
            return false;
        // Retry if the token has expired
        const oauthClientAuth = await this.oauthClientAuthState?.promise;
        if (response.status === 401 && oauthClientAuth && +oauthClientAuth.expires_at - Date.now() < 10 * 1000) {
            this.oauthClientAuthState = undefined;
            return true;
        }
        // Retry on request timeouts.
        if (response.status === 408)
            return true;
        // Retry on lock timeouts.
        if (response.status === 409)
            return true;
        // Retry on rate limits.
        if (response.status === 429)
            return true;
        // Retry internal errors.
        if (response.status >= 500)
            return true;
        return false;
    }
    async retryRequest(options, retriesRemaining, requestLogID, responseHeaders) {
        let timeoutMillis;
        // Note the `retry-after-ms` header may not be standard, but is a good idea and we'd like proactive support for it.
        const retryAfterMillisHeader = responseHeaders?.get('retry-after-ms');
        if (retryAfterMillisHeader) {
            const timeoutMs = parseFloat(retryAfterMillisHeader);
            if (!Number.isNaN(timeoutMs)) {
                timeoutMillis = timeoutMs;
            }
        }
        // About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After
        const retryAfterHeader = responseHeaders?.get('retry-after');
        if (retryAfterHeader && !timeoutMillis) {
            const timeoutSeconds = parseFloat(retryAfterHeader);
            if (!Number.isNaN(timeoutSeconds)) {
                timeoutMillis = timeoutSeconds * 1000;
            }
            else {
                timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
            }
        }
        // If the API asks us to wait a certain amount of time (and it's a reasonable amount),
        // just do what it says, but otherwise calculate a default
        if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1000)) {
            const maxRetries = options.maxRetries ?? this.maxRetries;
            timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
        }
        await (0, sleep_1.sleep)(timeoutMillis);
        return this.makeRequest(options, retriesRemaining - 1, requestLogID);
    }
    calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
        const initialRetryDelay = 0.5;
        const maxRetryDelay = 8.0;
        const numRetries = maxRetries - retriesRemaining;
        // Apply exponential backoff, but not more than the max.
        const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
        // Apply some jitter, take up to at most 25 percent of the retry time.
        const jitter = 1 - Math.random() * 0.25;
        return sleepSeconds * jitter * 1000;
    }
    async buildRequest(inputOptions, { retryCount = 0 } = {}) {
        const options = { ...inputOptions };
        const { method, path, query, defaultBaseURL } = options;
        const url = this.buildURL(path, query, defaultBaseURL);
        if ('timeout' in options)
            (0, values_1.validatePositiveInteger)('timeout', options.timeout);
        options.timeout = options.timeout ?? this.timeout;
        const { bodyHeaders, body } = this.buildBody({ options });
        const reqHeaders = await this.buildHeaders({ options: inputOptions, method, bodyHeaders, retryCount });
        const req = {
            method,
            headers: reqHeaders,
            ...(options.signal && { signal: options.signal }),
            ...(globalThis.ReadableStream &&
                body instanceof globalThis.ReadableStream && { duplex: 'half' }),
            ...(body && { body }),
            ...(this.fetchOptions ?? {}),
            ...(options.fetchOptions ?? {}),
        };
        return { req, url, timeout: options.timeout };
    }
    async buildHeaders({ options, method, bodyHeaders, retryCount, }) {
        let idempotencyHeaders = {};
        if (this.idempotencyHeader && method !== 'get') {
            if (!options.idempotencyKey)
                options.idempotencyKey = this.defaultIdempotencyKey();
            idempotencyHeaders[this.idempotencyHeader] = options.idempotencyKey;
        }
        const headers = (0, headers_1.buildHeaders)([
            idempotencyHeaders,
            {
                Accept: 'application/json',
                'User-Agent': this.getUserAgent(),
                'X-Stainless-Retry-Count': String(retryCount),
                ...(options.timeout ? { 'X-Stainless-Timeout': String(Math.trunc(options.timeout / 1000)) } : {}),
                ...(0, detect_platform_1.getPlatformHeaders)(),
            },
            await this.authHeaders(options),
            this._options.defaultHeaders,
            bodyHeaders,
            options.headers,
        ]);
        this.validateHeaders(headers);
        return headers.values;
    }
    buildBody({ options: { body, headers: rawHeaders } }) {
        if (!body) {
            return { bodyHeaders: undefined, body: undefined };
        }
        const headers = (0, headers_1.buildHeaders)([rawHeaders]);
        if (
        // Pass raw type verbatim
        ArrayBuffer.isView(body) ||
            body instanceof ArrayBuffer ||
            body instanceof DataView ||
            (typeof body === 'string' &&
                // Preserve legacy string encoding behavior for now
                headers.values.has('content-type')) ||
            // `Blob` is superset of `File`
            (globalThis.Blob && body instanceof globalThis.Blob) ||
            // `FormData` -> `multipart/form-data`
            body instanceof FormData ||
            // `URLSearchParams` -> `application/x-www-form-urlencoded`
            body instanceof URLSearchParams ||
            // Send chunked stream (each chunk has own `length`)
            (globalThis.ReadableStream && body instanceof globalThis.ReadableStream)) {
            return { bodyHeaders: undefined, body: body };
        }
        else if (typeof body === 'object' &&
            (Symbol.asyncIterator in body ||
                (Symbol.iterator in body && 'next' in body && typeof body.next === 'function'))) {
            return { bodyHeaders: undefined, body: Shims.ReadableStreamFrom(body) };
        }
        else {
            return tslib_1.__classPrivateFieldGet(this, _Telnyx_encoder, "f").call(this, { body, headers });
        }
    }
}
exports.Telnyx = Telnyx;
_a = Telnyx, _Telnyx_encoder = new WeakMap(), _Telnyx_instances = new WeakSet(), _Telnyx_baseURLOverridden = function _Telnyx_baseURLOverridden() {
    return this.baseURL !== 'https://api.telnyx.com/v2';
};
Telnyx.Telnyx = _a;
Telnyx.DEFAULT_TIMEOUT = 60000; // 1 minute
Telnyx.TelnyxError = Errors.TelnyxError;
Telnyx.APIError = Errors.APIError;
Telnyx.APIConnectionError = Errors.APIConnectionError;
Telnyx.APIConnectionTimeoutError = Errors.APIConnectionTimeoutError;
Telnyx.APIUserAbortError = Errors.APIUserAbortError;
Telnyx.NotFoundError = Errors.NotFoundError;
Telnyx.ConflictError = Errors.ConflictError;
Telnyx.RateLimitError = Errors.RateLimitError;
Telnyx.BadRequestError = Errors.BadRequestError;
Telnyx.AuthenticationError = Errors.AuthenticationError;
Telnyx.InternalServerError = Errors.InternalServerError;
Telnyx.PermissionDeniedError = Errors.PermissionDeniedError;
Telnyx.UnprocessableEntityError = Errors.UnprocessableEntityError;
Telnyx.toFile = Uploads.toFile;
Telnyx.Legacy = legacy_1.Legacy;
Telnyx.OAuth = oauth_1.OAuth;
Telnyx.OAuthClients = oauth_clients_1.OAuthClients;
Telnyx.OAuthGrants = oauth_grants_1.OAuthGrants;
Telnyx.Webhooks = webhooks_1.Webhooks;
Telnyx.AccessIPAddress = access_ip_address_1.AccessIPAddress;
Telnyx.AccessIPRanges = access_ip_ranges_1.AccessIPRanges;
Telnyx.Actions = actions_1.Actions;
Telnyx.Addresses = addresses_1.Addresses;
Telnyx.AdvancedOrders = advanced_orders_1.AdvancedOrders;
Telnyx.AI = ai_1.AI;
Telnyx.AuditEvents = audit_events_1.AuditEvents;
Telnyx.AuthenticationProviders = authentication_providers_1.AuthenticationProviders;
Telnyx.AvailablePhoneNumberBlocks = available_phone_number_blocks_1.AvailablePhoneNumberBlocks;
Telnyx.AvailablePhoneNumbers = available_phone_numbers_1.AvailablePhoneNumbers;
Telnyx.Balance = balance_1.Balance;
Telnyx.BillingGroups = billing_groups_1.BillingGroups;
Telnyx.BulkSimCardActions = bulk_sim_card_actions_1.BulkSimCardActions;
Telnyx.BundlePricing = bundle_pricing_1.BundlePricing;
Telnyx.CallControlApplications = call_control_applications_1.CallControlApplications;
Telnyx.CallEvents = call_events_1.CallEvents;
Telnyx.Calls = calls_1.Calls;
Telnyx.ChannelZones = channel_zones_1.ChannelZones;
Telnyx.ChargesBreakdown = charges_breakdown_1.ChargesBreakdown;
Telnyx.ChargesSummary = charges_summary_1.ChargesSummary;
Telnyx.Comments = comments_1.Comments;
Telnyx.Conferences = conferences_1.Conferences;
Telnyx.Connections = connections_1.Connections;
Telnyx.CountryCoverage = country_coverage_1.CountryCoverage;
Telnyx.CredentialConnections = credential_connections_1.CredentialConnections;
Telnyx.CustomStorageCredentials = custom_storage_credentials_1.CustomStorageCredentials;
Telnyx.CustomerServiceRecords = customer_service_records_1.CustomerServiceRecords;
Telnyx.DetailRecords = detail_records_1.DetailRecords;
Telnyx.DialogflowConnections = dialogflow_connections_1.DialogflowConnections;
Telnyx.DocumentLinks = document_links_1.DocumentLinks;
Telnyx.Documents = documents_1.Documents;
Telnyx.DynamicEmergencyAddresses = dynamic_emergency_addresses_1.DynamicEmergencyAddresses;
Telnyx.DynamicEmergencyEndpoints = dynamic_emergency_endpoints_1.DynamicEmergencyEndpoints;
Telnyx.ExternalConnections = external_connections_1.ExternalConnections;
Telnyx.FaxApplications = fax_applications_1.FaxApplications;
Telnyx.Faxes = faxes_1.Faxes;
Telnyx.FqdnConnections = fqdn_connections_1.FqdnConnections;
Telnyx.Fqdns = fqdns_1.Fqdns;
Telnyx.GlobalIPAllowedPorts = global_ip_allowed_ports_1.GlobalIPAllowedPorts;
Telnyx.GlobalIPAssignmentHealth = global_ip_assignment_health_1.GlobalIPAssignmentHealth;
Telnyx.GlobalIPAssignments = global_ip_assignments_1.GlobalIPAssignments;
Telnyx.GlobalIPAssignmentsUsage = global_ip_assignments_usage_1.GlobalIPAssignmentsUsage;
Telnyx.GlobalIPHealthCheckTypes = global_ip_health_check_types_1.GlobalIPHealthCheckTypes;
Telnyx.GlobalIPHealthChecks = global_ip_health_checks_1.GlobalIPHealthChecks;
Telnyx.GlobalIPLatency = global_ip_latency_1.GlobalIPLatency;
Telnyx.GlobalIPProtocols = global_ip_protocols_1.GlobalIPProtocols;
Telnyx.GlobalIPUsage = global_ip_usage_1.GlobalIPUsage;
Telnyx.GlobalIPs = global_ips_1.GlobalIPs;
Telnyx.InboundChannels = inbound_channels_1.InboundChannels;
Telnyx.IntegrationSecrets = integration_secrets_1.IntegrationSecrets;
Telnyx.InventoryCoverage = inventory_coverage_1.InventoryCoverage;
Telnyx.Invoices = invoices_1.Invoices;
Telnyx.IPConnections = ip_connections_1.IPConnections;
Telnyx.IPs = ips_1.IPs;
Telnyx.LedgerBillingGroupReports = ledger_billing_group_reports_1.LedgerBillingGroupReports;
Telnyx.List = list_1.List;
Telnyx.ManagedAccounts = managed_accounts_1.ManagedAccounts;
Telnyx.Media = media_1.Media;
Telnyx.Messages = messages_1.Messages;
Telnyx.Messaging = messaging_1.Messaging;
Telnyx.MessagingHostedNumberOrders = messaging_hosted_number_orders_1.MessagingHostedNumberOrders;
Telnyx.MessagingHostedNumbers = messaging_hosted_numbers_1.MessagingHostedNumbers;
Telnyx.MessagingNumbersBulkUpdates = messaging_numbers_bulk_updates_1.MessagingNumbersBulkUpdates;
Telnyx.MessagingOptouts = messaging_optouts_1.MessagingOptouts;
Telnyx.MessagingProfiles = messaging_profiles_1.MessagingProfiles;
Telnyx.MessagingTollfree = messaging_tollfree_1.MessagingTollfree;
Telnyx.MessagingURLDomains = messaging_url_domains_1.MessagingURLDomains;
Telnyx.MobileNetworkOperators = mobile_network_operators_1.MobileNetworkOperators;
Telnyx.MobilePushCredentials = mobile_push_credentials_1.MobilePushCredentials;
Telnyx.NetworkCoverage = network_coverage_1.NetworkCoverage;
Telnyx.Networks = networks_1.Networks;
Telnyx.NotificationChannels = notification_channels_1.NotificationChannels;
Telnyx.NotificationEventConditions = notification_event_conditions_1.NotificationEventConditions;
Telnyx.NotificationEvents = notification_events_1.NotificationEvents;
Telnyx.NotificationProfiles = notification_profiles_1.NotificationProfiles;
Telnyx.NotificationSettings = notification_settings_1.NotificationSettings;
Telnyx.NumberBlockOrders = number_block_orders_1.NumberBlockOrders;
Telnyx.NumberLookup = number_lookup_1.NumberLookup;
Telnyx.NumberOrderPhoneNumbers = number_order_phone_numbers_1.NumberOrderPhoneNumbers;
Telnyx.NumberOrders = number_orders_1.NumberOrders;
Telnyx.NumberReservations = number_reservations_1.NumberReservations;
Telnyx.NumbersFeatures = numbers_features_1.NumbersFeatures;
Telnyx.OperatorConnect = operator_connect_1.OperatorConnect;
Telnyx.OtaUpdates = ota_updates_1.OtaUpdates;
Telnyx.OutboundVoiceProfiles = outbound_voice_profiles_1.OutboundVoiceProfiles;
Telnyx.Payment = payment_1.Payment;
Telnyx.PhoneNumberBlocks = phone_number_blocks_1.PhoneNumberBlocks;
Telnyx.PhoneNumbers = phone_numbers_1.PhoneNumbers;
Telnyx.PhoneNumbersRegulatoryRequirements = phone_numbers_regulatory_requirements_1.PhoneNumbersRegulatoryRequirements;
Telnyx.PortabilityChecks = portability_checks_1.PortabilityChecks;
Telnyx.Porting = porting_1.Porting;
Telnyx.PortingOrders = porting_orders_1.PortingOrders;
Telnyx.PortingPhoneNumbers = porting_phone_numbers_1.PortingPhoneNumbers;
Telnyx.Portouts = portouts_1.Portouts;
Telnyx.PrivateWirelessGateways = private_wireless_gateways_1.PrivateWirelessGateways;
Telnyx.PublicInternetGateways = public_internet_gateways_1.PublicInternetGateways;
Telnyx.Queues = queues_1.Queues;
Telnyx.RcsAgents = rcs_agents_1.RcsAgents;
Telnyx.RecordingTranscriptions = recording_transcriptions_1.RecordingTranscriptions;
Telnyx.Recordings = recordings_1.Recordings;
Telnyx.Regions = regions_1.Regions;
Telnyx.RegulatoryRequirements = regulatory_requirements_1.RegulatoryRequirements;
Telnyx.Reports = reports_1.Reports;
Telnyx.RequirementGroups = requirement_groups_1.RequirementGroups;
Telnyx.RequirementTypes = requirement_types_1.RequirementTypes;
Telnyx.Requirements = requirements_1.Requirements;
Telnyx.RoomCompositions = room_compositions_1.RoomCompositions;
Telnyx.RoomParticipants = room_participants_1.RoomParticipants;
Telnyx.RoomRecordings = room_recordings_1.RoomRecordings;
Telnyx.Rooms = rooms_1.Rooms;
Telnyx.Seti = seti_1.Seti;
Telnyx.ShortCodes = short_codes_1.ShortCodes;
Telnyx.SimCardDataUsageNotifications = sim_card_data_usage_notifications_1.SimCardDataUsageNotifications;
Telnyx.SimCardGroups = sim_card_groups_1.SimCardGroups;
Telnyx.SimCardOrderPreview = sim_card_order_preview_1.SimCardOrderPreview;
Telnyx.SimCardOrders = sim_card_orders_1.SimCardOrders;
Telnyx.SimCards = sim_cards_1.SimCards;
Telnyx.SiprecConnectors = siprec_connectors_1.SiprecConnectors;
Telnyx.Storage = storage_1.Storage;
Telnyx.SubNumberOrders = sub_number_orders_1.SubNumberOrders;
Telnyx.SubNumberOrdersReport = sub_number_orders_report_1.SubNumberOrdersReport;
Telnyx.TelephonyCredentials = telephony_credentials_1.TelephonyCredentials;
Telnyx.Texml = texml_1.Texml;
Telnyx.TexmlApplications = texml_applications_1.TexmlApplications;
Telnyx.TextToSpeech = text_to_speech_1.TextToSpeech;
Telnyx.UsageReports = usage_reports_1.UsageReports;
Telnyx.UserAddresses = user_addresses_1.UserAddresses;
Telnyx.UserTags = user_tags_1.UserTags;
Telnyx.Verifications = verifications_1.Verifications;
Telnyx.VerifiedNumbers = verified_numbers_1.VerifiedNumbers;
Telnyx.VerifyProfiles = verify_profiles_1.VerifyProfiles;
Telnyx.VirtualCrossConnects = virtual_cross_connects_1.VirtualCrossConnects;
Telnyx.VirtualCrossConnectsCoverage = virtual_cross_connects_coverage_1.VirtualCrossConnectsCoverage;
Telnyx.WebhookDeliveries = webhook_deliveries_1.WebhookDeliveries;
Telnyx.WireguardInterfaces = wireguard_interfaces_1.WireguardInterfaces;
Telnyx.WireguardPeers = wireguard_peers_1.WireguardPeers;
Telnyx.Wireless = wireless_1.Wireless;
Telnyx.WirelessBlocklistValues = wireless_blocklist_values_1.WirelessBlocklistValues;
Telnyx.WirelessBlocklists = wireless_blocklists_1.WirelessBlocklists;
Telnyx.WellKnown = well_known_1.WellKnown;
Telnyx.InexplicitNumberOrders = inexplicit_number_orders_1.InexplicitNumberOrders;
Telnyx.MobilePhoneNumbers = mobile_phone_numbers_1.MobilePhoneNumbers;
Telnyx.MobileVoiceConnections = mobile_voice_connections_1.MobileVoiceConnections;
Telnyx.Messaging10dlc = messaging_10dlc_1.Messaging10dlc;
Telnyx.SpeechToText = speech_to_text_1.SpeechToText;
Telnyx.Organizations = organizations_1.Organizations;
//# sourceMappingURL=client.js.map